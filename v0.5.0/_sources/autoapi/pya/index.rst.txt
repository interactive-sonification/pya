:py:mod:`pya`
=============

.. py:module:: pya


Subpackages
-----------
.. toctree::
   :titlesonly:
   :maxdepth: 3

   backend/index.rst
   helper/index.rst


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   amfcc/index.rst
   arecorder/index.rst
   aserver/index.rst
   asig/index.rst
   aspec/index.rst
   astft/index.rst
   ugen/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   pya.Aserver
   pya.Asig
   pya.Astft
   pya.Aspec
   pya.Amfcc
   pya.Ugen
   pya.DummyBackend
   pya.PyAudioBackend



Functions
~~~~~~~~~

.. autoapisummary::

   pya.basicplot
   pya.gridplot
   pya.audio_read
   pya.linlin
   pya.midicps
   pya.cpsmidi
   pya.dbamp
   pya.ampdb
   pya.spectrum
   pya.normalize
   pya.audio_from_file
   pya.buf_to_float
   pya.device_info
   pya.find_device
   pya.padding
   pya.is_pow2
   pya.next_pow2
   pya.round_half_up
   pya.rolling_window
   pya.signal_to_frame
   pya.magspec
   pya.powspec
   pya.hz2mel
   pya.mel2hz
   pya.determine_backend
   pya.startup
   pya.shutdown



Attributes
~~~~~~~~~~

.. autoapisummary::

   pya._LOGGER


.. py:class:: Aserver(sr=44100, bs=512, device=None, channels=2, backend=None, **kwargs)


   Pya audio server
   Based on pyaudio, works as a FIFO style audio stream pipeline,
   allowing Asig.play() to send audio segement into the stream.

   Examples:
   -----------
   >>> from pya import *
   >>> ser = Aserver()
   >>> ser.boot()
   AServer: sr: 44100, blocksize: ...,
            Stream Active: True, Device: ...
   >>> asine = Ugen().sine()
   >>> asine.play(server=ser)
   Asig('sine'): 1 x 44100 @ 44100Hz = 1.000s cn=['0']

   .. py:property:: device_dict


   .. py:property:: max_out_chn


   .. py:property:: max_in_chn


   .. py:property:: device


   .. py:property:: is_active
      :type: bool


   .. py:attribute:: default

      

   .. py:method:: startup_default_server(**kwargs)
      :staticmethod:


   .. py:method:: shutdown_default_server()
      :staticmethod:


   .. py:method:: __repr__()

      Return repr(self).


   .. py:method:: get_devices(verbose=False)

      Return (and optionally print) available input and output device


   .. py:method:: set_device(idx, reboot=True)

      Set audio device

      :param idx: Index of the device
      :type idx: int
      :param reboot: If true the server will reboot. (Default value = True)
      :type reboot: bool


   .. py:method:: boot()

      boot Aserver = start stream, setting its callback to this callback.


   .. py:method:: quit()

      Aserver quit server: stop stream and terminate pa


   .. py:method:: play(asig, onset=0, out=0, **kwargs)

      Dispatch asigs or arrays for given onset.


   .. py:method:: _play_callback(in_data, frame_count, time_info, flag)

      callback function, called from pastream thread when data needed.


   .. py:method:: stop()


   .. py:method:: __enter__()


   .. py:method:: __exit__(exc_type, exc_value, traceback)


   .. py:method:: __del__()



.. py:class:: Asig(sig, sr=44100, label='', channels=1, cn=None)


   Audio signal class.
   Asig enables manipulation of audio signals in the style of numpy and more.
   Asig offer functions for plotting (via matplotlib) and playing audio
   (using the pya.Aserver class)

   .. attribute:: sig

      Array for the audio signal. Can be mono or multichannel.

      :type: numpy.array

   .. attribute:: sr

      Sampling rate

      :type: int

   .. attribute:: label

      A string label to give the object a unique identifier.

      :type: str

   .. attribute:: channels

      Number of channels

      :type: int

   .. attribute:: cn

      cn short for channel names is a list of string of size channels,
      to give each channel a unique name.
      channel names can be used to subset signal channels in
      a more readible way,
      e.g. asig[:, ['left', 'front']] subsets the left and
      front channels of the signal.

      :type: list of str, None

   .. attribute:: mix_mode

      used to extend numpy __setitem__() operation to
      frequent audio manipulations such as
      mixing, extending, boundary, replacing.
      Current Asig supports the mix_modes:
      bound, extend, overwrite.  mix_mode should not be
      set directly but is set temporarilty when using
      the .bound, .extend and .overwrite properties.

      :type: str or None

   .. py:property:: channels

      Return the number of channels

   .. py:property:: cn

      Channel names getter

   .. py:property:: samples
      :type: int

      Return the length of signal in samples

   .. py:property:: dur
      :type: float

      Return the duration in seconds

   .. py:property:: x

      this mode allows destination
      sig size in assignment to be extended through setitem

      :type: Extend mode

   .. py:property:: b

      this mode allows to truncate a source signal
      in assignment to a limited destination in setitem.

      :type: Bound mode

   .. py:property:: o

      this mode cuts and replaces target
      selection by source signal on assignment via setitem

      :type: Overwrite mode

   .. py:attribute:: extend

      

   .. py:attribute:: bound

      

   .. py:attribute:: overwrite

      

   .. py:method:: save_wavfile(fname='asig.wav', dtype='float32')

      Save signal as .wav file, return self.

      :param fname: name of the file with .wav (Default value = "asig.wav")
      :type fname: str
      :param dtype: datatype (Default value = 'float32')
      :type dtype: str


   .. py:method:: _set_col_names()


   .. py:method:: __getitem__(index)

      Accessing array elements through slicing.
          * int, get signal row asig[4];
          * slice, range and step slicing asig[4:40:2]
              # from 4 to 40 every 2 samples;
          * list, subset rows, asig[[2, 4, 6]]
              # pick out index 2, 4, 6 as a new asig
          * tuple, row and column specific slicing, asig[4:40, 3:5]
              # from 4 to 40, channel 3 and 4
          * Time slicing (unit in seconds) using dict asig[{1:2.5}, :]
              creates indexing of 1s to 2.5s.
          * Channel name slicing: asig['l'] returns channel 'l' as
              a new mono asig. asig[['front', 'rear']], etc...
          * bool, subset channels: asig[:, [True, False]]


      :param index: Slicing argument.
      :type index: Number or slice or list or tuple or dict

      :returns: **a** -- __getitem__ returns a subset of the self based on the slicing.
      :rtype: Asig


   .. py:method:: __setitem__(index, value)

      setitem: asig[index] = value. This allows all the methods from getitem:
          * numpy style slicing
          * string/string_list for subsetting based on channel name
          * time slicing (unit seconds) via dict.
          * bool slicing to filter out specific channels.
      In addition, there are 4 possible modes:
      (referring to asig as 'dest', and value as 'src'
          1. standard pythonic way that the src and
          dest dimensions need to match
              asig[...] = value
          2. bound mode where src is copied up to the bounds of dest
              asig.b[...] = value
          3. extend mode where dest is dynamically
          extended to make space for src
              asig.x[...] = value
          4. overwrite mode where selected dest subset is
          replaced by specified src regardless the length.
              asig.o[...] = value

      row index:
          * list: e.g. [1,2,3,4,5,6] or [True, ..., False]
              (modes b and x possible)
          * int:  e.g. 0  (i.e. a single sample, so no need for extra modes)
          * slice: e.g. 100:5000:2  (can be used with all modes)
          * dict: e.g. {0.5: 2.5}
              (modes o, b possible, x only if step==1,
              or if step==None and stop=None)

      :param index: Slicing argument.
      :type index: Number or slice or list or tuple or dict
      :param value: value to set
      :type value: Asig or numpy.ndarray or list

      :returns: **_** -- Updated asig
      :rtype: Asig


   .. py:method:: resample(target_sr=44100, rate=1, kind='linear')

      Resample signal based on interpolation, can process multichannel signals.

      :param target_sr: Target sampling rate (Default value = 44100)
      :type target_sr: int
      :param rate: Rate to speed up or slow down the audio (Default value = 1)
      :type rate: float
      :param kind: Type of interpolation (Default value = 'linear')
      :type kind: str

      :returns: **_** -- Asig with resampled signal.
      :rtype: Asig


   .. py:method:: play(rate=1, server=None, onset=0, channel=0, block=False)

      Play Asig audio via Aserver, using Aserver.default (if existing)
      kwargs are propagated to Aserver:play(onset=0, out=0)

      :param rate: Playback rate (Default value = 1)
      :type rate: float
      :param \*\*kwargs:
                         'server' : Aserver
                             Set which server to play. e.g. s = Aserver(); s.boot(); asig.play(server=s)
      :type \*\*kwargs: str

      :returns: **_** -- return self
      :rtype: Asig


   .. py:method:: shift_channel(shift=0)

      Shift signal to other channels. This is particular useful for assigning a mono signal to a specific channel.
          * shift = 0: does nothing as the same signal is being routed to the same position
          * shift > 0: shift channels of self.sig 'right', i.e. from [0,..channels-1] to channels [shift,shift+1,...]
          * shift < 0: shift channels of self.sig 'left', i.e. the first shift channels will be discarded.

      :param shift: shift channel amount (Default value = 0)
      :type shift: int

      :returns: **_** -- Rerouted asig
      :rtype: Asig


   .. py:method:: mono(blend=None)

      Mix channels to mono signal. Perform sig = np.sum(self.sig_copy * blend, axis=1)

      :param blend: list of gain for each channel as a multiplier.
                    Do nothing if signal is already mono, raise warning (Default value = None)
      :type blend: list

      :returns: **_** -- A mono Asig object
      :rtype: Asig


   .. py:method:: stereo(blend=None)

      Blend all channels of the signal to stereo. Applicable for any single-/ or multi-channel Asig.

      :param blend: Usage: For mono, blend=(g1, g2), the  channel will be broadcated to left, right with g1, g2 gains.
                    For stereo signal, blend=(g1, g2), each channel is gain adjusted by g1, g2.
                    For multichannel: blend = [[list of gains for left channel], [list of gains for right channel]]
                    Default value = None, resulting in equal distribution to left and right channel
      :type blend: list or None

      .. rubric:: Example

      asig[:,['c1','c2','c3']].stereo[[1, 0.707, 0], [0, 0.707, 1]]
          mixes channel 'c1' to left, 'c2' to center and 'c3' to right channel
          of a new stereo asig. Note that for equal loudness left**2+right**2=1 should be used

      :returns: **_** -- A stereo Asig object
      :rtype: Asig


   .. py:method:: rewire(dic)

      Rewire channels to flexibly allow weighted channel permutations.

      :param dic: key = tuple of (source channel, destination channel)
                  value = amplitude gain
      :type dic: dict

      .. rubric:: Example

      {(0, 1): 0.2, (5, 0): 0.4}: rewire channel 0 to 1 with gain 0.2, and 5 to 1 with gain 2
      leaving other channels unmodified

      :returns: **_** -- Asig with rewired channels..
      :rtype: Asig


   .. py:method:: pan2(pan=0.0)

      Stereo panning of asig to a stereo output.
      Panning is based on constant power panning, see pan below
      Behavior depends on nr of channels self.channels
      * multi-channel signals (self.channels>2) are cut back to stereo and treated as
      * stereo signals (self.channels==2) are channelwise attenuated using cos(angle), sin(angle)
      * mono signals (self.channels==1) result in stereo output asigs.

      :param pan: panning between -1. (left) to 1. (right)  (Default value = 0.)
      :type pan: float

      :returns: **_** -- Asig
      :rtype: Asig


   .. py:method:: remove_DC()

      remove DC offset

      :param none:

      :returns: **_** -- channelwise DC-free Asig.
      :rtype: Asig


   .. py:method:: norm(norm=1, in_db=False, dcflag=False)

      Normalize signal

      :param norm: normalize threshold (Default value = 1)
      :type norm: float
      :param in_db: Normally, norm takes amplitude, if in_db, norm's unit is in dB.
      :type in_db: bool
      :param dcflag: If true, remove DC offset (Default value = False)
      :type dcflag: bool

      :returns: **_** -- normalized Asig.
      :rtype: Asig


   .. py:method:: gain(amp=None, db=None)

      Apply gain in amplitude or dB, only use one or the other arguments. Argument can be either a scalar
      or a list (to apply individual gain to each channel). The method returns a new asig with gain applied.

      :param amp: Amplitude (Default value = None)
      :type amp: float or None
      :param db: Decibel (Default value = None)
      :type db: float or int or None

      :returns: **_** -- Gain adjusted Asig.
      :rtype: Asig


   .. py:method:: rms(axis=0)

      Return signal's RMS

      :param axis: Axis to perform np.mean() on (Default value = 0)
      :type axis: int

      :returns: **_** -- RMS value
      :rtype: float


   .. py:method:: plot(fn=None, offset=0, scale=1, x_as_time=True, ax=None, xlim=None, ylim=None, **kwargs)

      Display signal graph

      :param fn: Keyword or function (Default value = None)
      :type fn: func or None
      :param offset: Offset each channel to create a stacked view (Default value = 0)
      :type offset: int or float
      :param scale: Scale the y value (Default value = 1)
      :type scale: float
      :param xlim: x axis range (Default value = None)
      :type xlim: tuple or list
      :param ylim: y axis range (Default value = None)
      :type ylim: tuple or list
      :param \*\*kwargs: keyword arguments for matplotlib.pyplot.plot()

      :returns: **_** -- self, you can use plt.show() to display the plot.
      :rtype: Asig


   .. py:method:: get_duration()

      Return the duration in second.


   .. py:method:: get_times()

      Get time stamps for left-edge of sample-and-hold-signal


   .. py:method:: __eq__(other)

      Check if two asig objects have the same signal. But does not care about sr and others


   .. py:method:: __repr__()

      Report key attributes


   .. py:method:: __mul__(other)

      Magic method for multiplying. You can either multiply a scalar or an Asig object. If muliplying an Asig,
      you don't always need to have same size arrays as audio signals may different in length. If mix_mode
      is set to 'bound' the size is fixed to respect self. If not, the result will respect to whichever the
      bigger array is.


   .. py:method:: __rmul__(other)


   .. py:method:: __truediv__(other)

      Magic method for division. You can either divide a scalar or an Asig object.
      Use division with caution, audio signal is common to reach 0 or near,
      avoid zero division or extremely large result.

      If dividing an Asig, you don't always need to have same size arrays as audio signals
      may different in length. If mix_mode is set to 'bound' the size is fixed to respect self.
      If not, the result will respect to whichever the bigger array is.


   .. py:method:: __rtruediv__(other)


   .. py:method:: __add__(other)

      Magic method for adding. You can either add a scalar or an Asig object. If adding an Asig,
      you don't always need to have same size arrays as audio signals may different in length. If mix_mode
      is set to 'bound' the size is fixed to respect self. If not, the result will respect to whichever the
      bigger array is.


   .. py:method:: __radd__(other)


   .. py:method:: __sub__(other)

      Magic method for subtraction. You can either minus a scalar or an Asig object. If subtracting an Asig,
      you don't always need to have same size arrays as audio signals may different in length. If mix_mode
      is set to 'bound' the size is fixed to respect self. If not, the result will respect to whichever the
      bigger array is.


   .. py:method:: __rsub__(other)


   .. py:method:: find_events(step_dur=0.001, sil_thr=-20, evt_min_dur=0, sil_min_dur=0.1, sil_pad=[0.001, 0.1])

      Locate meaningful 'events' in the signal and create event list. Onset detection.

      :param step_dur: duration in seconds of each search step (Default value = 0.001)
      :type step_dur: float
      :param sil_thr: silent threshold in dB (Default value = -20)
      :type sil_thr: int
      :param evt_min_dur: minimum duration to be counted as an event (Default value = 0)
      :type evt_min_dur: float
      :param sil_min_dur: minimum duration to be counted as silent (Default value = 0.1)
      :type sil_min_dur: float
      :param sil_pad: this allows you to add a small duration before and after the actual
                      found event locations to the event ranges. If it is a list, you can set the padding (Default value = [0.001)
      :type sil_pad: list
      :param 0.1]:

      :returns: **_** -- This method returns self. But the list of events can be accessed through self._['events']
      :rtype: Asig


   .. py:method:: select_event(index=None, onset=None)

      This method can be called after find_event (aka onset detection).

      :param index: Index of the event (Default value = None)
      :type index: int or None
      :param onset: Onset of the event (Default value = None)
      :type onset: int or None

      :returns: **_** -- self
      :rtype: Asig


   .. py:method:: plot_events()


   .. py:method:: fade_in(dur=0.1, curve=1)

      Fade in the signal at the beginning

      :param dur: Duration in seconds to fade in (Default value = 0.1)
      :type dur: float
      :param curve: Curvature of the fader, power of the linspace function. (Default value = 1)
      :type curve: float

      :returns: **_** -- Asig, new asig with the fade in signal
      :rtype: Asig


   .. py:method:: fade_out(dur=0.1, curve=1)

      Fade out the signal at the end

      :param dur: duration in seconds to fade out (Default value = 0.1)
      :type dur: float
      :param curve: Curvature of the fader, power of the linspace function. (Default value = 1)
      :type curve: float

      :returns: **_** -- Asig, new asig with the fade out signal
      :rtype: Asig


   .. py:method:: iirfilter(cutoff_freqs, btype='bandpass', ftype='butter', order=4, filter='lfilter', rp=None, rs=None)

      iirfilter based on scipy.signal.iirfilter

      :param cutoff_freqs: Cutoff frequency or frequencies.
      :type cutoff_freqs: float or [float, float]
      :param btype: Filter type (Default value = 'bandpass')
      :type btype: str
      :param ftype: Tthe type of IIR filter. e.g. 'butter', 'cheby1', 'cheby2', 'elip', 'bessel' (Default value = 'butter')
      :type ftype: str
      :param order: Filter order (Default value = 4)
      :type order: int
      :param filter: The scipy.signal method to call when applying the filter coeffs to the signal.
                     by default it is set to scipy.signal.lfilter (one-dimensional).
      :type filter: str
      :param rp: For Chebyshev and elliptic filters, provides the maximum ripple in the passband. (dB) (Default value = None)
      :type rp: float
      :param rs: For Chebyshev and elliptic filters, provides the minimum attenuation in the stop band. (dB) (Default value = None)
      :type rs: float

      :returns: **_** -- new Asig with the filter applied. also you can access b, a coefficients by doing self._['b']
                and self._['a']
      :rtype: Asig


   .. py:method:: plot_freqz(worN, **kwargs)

      Plot the frequency response of a digital filter. Perform scipy.signal.freqz then plot the response.

      TODO
      :param worN:
      :param \*\*kwargs:


   .. py:method:: envelope(amps, ts=None, curve=1, kind='linear')

      Create an envelop and multiply by the signal.

      :param amps: Amplitude of each breaking point
      :type amps: array
      :param ts: Indices of each breaking point (Default value = None)
      :type ts: array
      :param curve: Affecting the curvature of the ramp. (Default value = 1)
      :type curve: int
      :param kind: The type of interpolation (Default value = 'linear')
      :type kind: str

      :returns: **_** -- Returns a new asig with the enveloped applied to its signal array
      :rtype: Asig


   .. py:method:: adsr(att=0, dec=0.1, sus=0.7, rel=0.1, curve=1, kind='linear')

      Create and applied a ADSR evelope to signal.

      :param att: attack (Default value = 0)
      :type att: float
      :param dec: decay (Default value = 0.1)
      :type dec: float
      :param sus: sustain (Default value = 0.7)
      :type sus: float
      :param rel: release. (Default value = 0.1)
      :type rel: float
      :param curve: affecting the curvature of the ramp. (Default value = 1)
      :type curve: int
      :param kind: The type of interpolation (Default value = 'linear')
      :type kind: str

      :returns: **_** -- returns a new asig with the enveloped applied to its signal array
      :rtype: Asig


   .. py:method:: window(win='triang', **kwargs)

      Apply windowing to self.sig

      :param win: Type of window check scipy.signal.get_window for avaiable types. (Default value = 'triang')
      :type win: str
      :param \*\*kwargs: keyword arguments for scipy.signal.get_window()

      :returns: **_** -- new asig with window applied.
      :rtype: Asig


   .. py:method:: window_op(nperseg=64, stride=32, win=None, fn='rms', pad='mirror')

      TODO add docstring

      :param nperseg: (Default value = 64)
      :param stride: (Default value = 32)
      :param win: (Default value = None)
      :param fn: (Default value = 'rms')
      :param pad: (Default value = 'mirror')


   .. py:method:: overlap_add(nperseg=64, stride_in=32, stride_out=32, jitter_in=None, jitter_out=None, win=None, pad='mirror')

      TODO

      :param nperseg: (Default value = 64)
      :param stride_in: (Default value = 32)
      :param stride_out: (Default value = 32)
      :param jitter_in: (Default value = None)
      :param jitter_out: (Default value = None)
      :param win: (Default value = None)
      :param pad: (Default value = 'mirror')


   .. py:method:: to_spec()

      Return Aspec object which is the rfft of the signal.


   .. py:method:: to_stft(**kwargs)

      Return Astft object which is the stft of the signal. Keyword arguments are the arguments for
      scipy.signal.stft().


   .. py:method:: to_mfcc(n_per_frame=None, hopsize=None, nfft=None, window='hann', nfilters=26, ncep=13, ceplifter=22, preemph=0.95, append_energy=True)

      Return Amfcc object.


   .. py:method:: plot_spectrum(offset=0, scale=1.0, xlim=None, **kwargs)

      Plot spectrum of the signal

      :param offset: If self.sig is multichannels, this will offset each
                     channels to create a stacked view for better viewing (Default value = 0.)
      :type offset: float
      :param scale: scale the y_axis (Default value = 1.)
      :type scale: float
      :param xlim: range of x_axis (Default value = None)
      :type xlim: tuple
      :param \*\*kwargs: keywords arguments for matplotlib.pyplot.plot()

      :returns: **_** -- self
      :rtype: Asig


   .. py:method:: spectrogram(*argv, **kvarg)

      Perform sicpy.signal.spectrogram and returns: frequencies, array of times, spectrogram



   .. py:method:: get_size()

      Return signal array shape and duration in seconds.


   .. py:method:: append(asig, amp=1)

      Apppend an asig with another. Conditions: the appended asig should have the same channels. If
      appended asig has a different sampling rate, resample it to match the orginal.

      :param asig: object to append
      :type asig: Asig
      :param amp: aplitude (Default value = 1)
      :type amp: float or int

      :returns: **_** -- Appended Asig object
      :rtype: Asig


   .. py:method:: add(sig, pos=None, amp=1, onset=None)

      Add a signal

      :param sig: Signal to add
      :type sig: asig
      :param pos: Postion to add (Default value = None)
      :type pos: int, None
      :param amp: Aplitude (Default value = 1)
      :type amp: float
      :param onset: Similar to pos but in time rather sample,
                    given a value to this will overwrite pos (Default value = None)
      :type onset: float or None

      :returns: **_** -- Asig with the added signal.
      :rtype: Asig


   .. py:method:: flatten()

      Flatten a multidimentional array into a vector using np.ravel()


   .. py:method:: pad(width=0, tail=True, constant_values=0, dur=None)

      Pads the signal

      :param width: The number of samples to append to the tail or head of the array.
      :type width: int
      :param tail: By default it is True, if trail pad to the end, else pad to the start.
      :type tail: bool
      :param constant_values: value to be padded, defaults to 0
      :type constant_values: float32
      :param dur: duration to be padded;  if specified, it overrides the parameter width
      :type dur: float

      :returns: **_** -- Asig of the pad signal.
      :rtype: Asig


   .. py:method:: custom(func, **kwargs)

      custom function method. TODO add example


   .. py:method:: convolve(sig, mode='full', method='fft', norm='amp')

      Convolution based on scipy.signal.convolve.

      :param ins: Input signal to convolve with, e.g. impulse response.
      :type ins: Asig or array_like
      :param mode: A string indicating the size of the output:
                   full
                       The output is the full discrete linear convolution of the inputs. (Default)
                   valid
                       The output consists only of those elements that do not rely on the zero-padding.
                       self.sr or ins must be at least as large as the other in every dimension.
                   same
                       The output is the same size as self.sr, centered with respect to the full output.
      :type mode: str {'full', 'valid', 'same'}, optional
      :param method: A string indicating which method to use to calculate the convolution
                     direct
                         Compute directly from sums, the definition of convolution
                     fft (default)
                         The Fourier Transform is used to perform the convolution by calling fftconvolve
                     auto
                         Automatically chooses direct or Fourier method based on an estimate of which is faster.
      :type method: str {'auto', 'direct', 'fft'}, optional
      :param norm: If "amp" (default value), the result signal will have the same peak as the original signal.
                   If "none" or other unrecognized name, no normalization is applied.
      :type norm: str, optional

      :returns: **_** -- A new asig with convlved signal. The size will depends on mode.
      :rtype: Asig


   .. py:method:: apply(fn)

      apply a fn samplewise for distortion or waveshaping a signal.

      :param fn: function to be used for wave shaping.
      :type fn: scalar function

      :returns: **_** -- A new asig with samplewise applied fn.
      :rtype: Asig



.. py:class:: Astft(x, sr=None, label=None, window='hann', nperseg=256, noverlap=None, nfft=None, detrend=False, return_onesided=True, boundary='zeros', padded=True, cn=None)


   Audio spectrogram (STFT) class, attributes refers to scipy.signal.stft. With an addition
   attribute cn being the list of channel names, and label being the name of the Asig

   .. py:method:: to_sig(**kwargs)

      Create signal from stft, i.e. perform istft,
      kwargs overwrite Astft values for istft

      :param \*\*kwargs:
                         optional keyboard arguments used in istft:
                             'sr', 'window', 'nperseg', 'noverlap',
                             'nfft', 'input_onesided', 'boundary'.
                         also convert 'sr' to 'fs' since scipy uses 'fs' as sampling frequency.
      :type \*\*kwargs: str

      :returns: **_** -- Asig
      :rtype: Asig


   .. py:method:: plot(fn=lambda x: x, ax=None, offset=0, scale=1.0, xlim=None, ylim=None, show_bar=True, **kwargs)

      Plot spectrogram

      :param fn: a function, by default is bypass
      :type fn: func
      :param ch: By default it is None,
      :type ch: int or str or None
      :param ax: you can assign your plot to specific axes (Default value = None)
      :type ax: matplotlib.axes
      :param xlim: x_axis range (Default value = None)
      :type xlim: tuple or list
      :param ylim: y_axis range (Default value = None)
      :type ylim: tuple or list
      :param \*\*kwargs: keyward arguments of matplotlib's pcolormesh

      :returns: **_** -- self
      :rtype: Asig


   .. py:method:: __repr__()

      Return repr(self).



.. py:class:: Aspec(x, sr=44100, label=None, cn=None)


   Audio spectrum class using rfft

   .. py:method:: get_duration()

      Return the duration in second.


   .. py:method:: to_sig()

      Convert Aspec into Asig


   .. py:method:: weight(weights, freqs=None, curve=1, kind='linear')

      TODO

      :param weights:
      :param freqs: (Default value = None)
      :param curve: (Default value = 1)
      :param kind: (Default value = 'linear')


   .. py:method:: plot(fn=np.abs, ax=None, offset=0, scale=1, xlim=None, ylim=None, **kwargs)

      Plot spectrum

      :param fn: function for processing the rfft spectrum. (Default value = np.abs)
      :type fn: func
      :param x_as_time: By default x axis display the time, if faulse display samples
      :type x_as_time: bool, optional
      :param xlim: Set x axis range (Default value = None)
      :type xlim: tuple or list or None
      :param ylim: Set y axis range (Default value = None)
      :type ylim: tuple or list or None
      :param offset: This is the absolute value each plot is shift vertically
                     to each other.
      :type offset: int or float
      :param scale: Scaling factor of the plot, use in multichannel plotting.
      :type scale: float
      :param \*\*kwargs: Keyword arguments for matplotlib.pyplot.plot()

      :returns: **_** -- self
      :rtype: Asig


   .. py:method:: __repr__()

      Return repr(self).



.. py:class:: Amfcc(x, sr=None, label='', n_per_frame=None, hopsize=None, nfft=None, window='hann', nfilters=26, ncep=13, ceplifter=22, preemph=0.95, append_energy=True, cn=None)


   Mel filtered Fourier spectrum (MFCC) class,
   this class is inspired by jameslyons/python_speech_features,
   https://github.com/jameslyons/python_speech_features
   Steps of mfcc:
       * Frame the signal into short frames.
       * For each frame calculate the periodogram estimate of the
       power spectrum.
       * Apply the mel filterbank to the power spectra, sum the energy
       in each filter.
       * Take the DCT of the log filterbank energies.
       * Keep DCT coefficients 2-13, discard the rest.
       * Take the logarithm of all filterbank energies.

   .. attribute:: x

      x can be two forms, the most commonly used is an Asig object.
      Such as directly acquired from an Asig object via Asig.to_stft().

      :type: Asig or numpy.ndarray

   .. attribute:: sr

      sampling rate, this is only necessary if x is not Asig.

      :type: int

   .. attribute:: duration

      Duration of the signal in second,

      :type: float

   .. attribute:: label

      A string label as an identifier.

      :type: str

   .. attribute:: n_per_frame

      Number of samples per frame

      :type: int

   .. attribute:: hopsize

      Number of samples of each successive frame.

      :type: int

   .. attribute:: nfft

      FFT size, default to be next power of 2 integer of n_per_frame

      :type: int

   .. attribute:: window

      Type of the window function (Default value='hann'),
      use scipy.signal.get_window to return a numpy array.
      If None, no windowing will be applied.

      :type: str

   .. attribute:: nfilters

      The number of mel filters. Default is 26

      :type: int

   .. attribute:: ncep

      Number of cepstrum. Default is 13

      :type: int

   .. attribute:: cepliter

      Lifter's cepstral coefficient. Default is 22

      :type: int

   .. attribute:: frames

      The original signal being reshape into frame based on
      n_per_frame and hopsize.

      :type: numpy.ndarray

   .. attribute:: frame_energy

      Total power spectrum energy of each frame.

      :type: numpy.ndarray

   .. attribute:: filter_banks

      An array of mel filters

      :type: numpy.ndarray

   .. attribute:: cepstra

      An array of the MFCC coeffcient, size: nframes x ncep

      :type: numpy.ndarray

   .. py:property:: nframes


   .. py:property:: timestamp


   .. py:property:: features

      The features refer to the cepstra

   .. py:method:: __repr__()

      Return repr(self).


   .. py:method:: preemphasis(x, coeff=0.97)
      :staticmethod:

      Pre-emphasis filter to whiten the spectrum.
      Pre-emphasis is a way of compensating for the
      rapid decaying spectrum of speech.
      Can often skip this step in the cases of music for example

      :param x: Signal array
      :type x: numpy.ndarray
      :param coeff: Preemphasis coefficient. The larger the stronger smoothing
                    and the slower response to change.
      :type coeff: float

      :returns: **_** -- The whitened signal.
      :rtype: numpy.ndarray


   .. py:method:: mel_filterbanks(sr, nfilters=26, nfft=512, lowfreq=0, highfreq=None)
      :staticmethod:

      Compute a Mel-filterbank. The filters are stored in the rows,
      the columns correspond to fft bins. The filters are returned as
      an array of size nfilt * (nfft/2 + 1)

      :param sr: Sampling rate
      :type sr: int
      :param nfilters: The number of filters, default 20
      :type nfilters: int
      :param nfft: The size of FFT, default 512
      :type nfft: int
      :param lowfreq: The lowest band edge of the mel filters, default 0 Hz
      :type lowfreq: int or float
      :param highfreq: The highest band edge of the mel filters, default sr // 2
      :type highfreq: int or float

      :returns: **_** -- A numpy array of size nfilt * (nfft/2 + 1)
                containing filterbank. Each row holds 1 filter.
      :rtype: numpy.ndarray


   .. py:method:: lifter(cepstra, L=22)
      :staticmethod:

      Apply a cepstral lifter the the matrix of cepstra.
      This has the effect of increasing the magnitude of
      the high frequency DCT coeffs.

      Liftering operation is similar to filtering operation in the
      frequency domain
      where a desired quefrency region for analysis is selected
      by multiplying the whole cepstrum
      by a rectangular window at the desired position.
      There are two types of liftering performed,
      low-time liftering and high-time liftering.
      Low-time liftering operation is performed to extract
      the vocal tract characteristics in the quefrency domain
      and high-time liftering is performed to get the excitation
      characteristics of the analysis speech frame.


      :param cepstra: The matrix of mel-cepstra
      :type cepstra: numpy.ndarray
      :param L: The liftering coefficient to use. Default is 22,
                since cepstra usually has 13 elements, 22
                L will result almost half pi of sine lift.
                It essential try to emphasis to lower ceptral coefficient
                while deemphasize higher ceptral coefficient as they are
                less discriminative for speech contents.
      :type L: int


   .. py:method:: plot(cmap='inferno', show_bar=True, offset=0, scale=1.0, xlim=None, ylim=None, x_as_time=True, nxlabel=8, ax=None, **kwargs)

      Plot Amfcc.features via matshow, x is frames/time, y is the MFCCs

      :param figsize: Figure size, width, height in inches, Default = [6.4, 4.8]
      :type figsize: (float, float), optional, default: None
      :param cmap: colormap for matplotlib. Default is 'inferno'.
      :type cmap: str
      :param show_bar: Default is True, show colorbar.
      :type show_bar: bool, optional
      :param x_as_time: Default is True, show x axis as time or sample index.
      :type x_as_time: bool, optional
      :param nxlabel: The amountt of labels on the x axis. Default is 8 .
      :type nxlabel: int, optional



.. py:class:: Ugen


   Bases: :py:obj:`pya.Asig`

   Unit Generator for to create Asig with predefined signal

   Currently avaiable:
       sine, cos, square, sawtooth, noise

   .. rubric:: Examples

   Create common waveform in Asig.

   >>> from pya import Ugen
   >>> # Create a sine wave of 440Hz at 44100Hz sr for 2 seconds. Same for cos()
   >>> sine = Ugen().sine(freq=440, amp=0.8, dur=2.,label="sine")
   >>> # Create a square wave of 25Hz, 2000 samples at 100 sr, stereo.
   >>> sq = Ugen().square(freq=25, n_rows=2000, sr=100, channels=2, cn=['l', 'r'])
   >>> # Make a white noise, another option is 'pink', at 44100Hz for 1second.
   >>> noi = Ugen().noise(type='white')

   .. py:method:: sine(freq=440, amp=1.0, dur=None, n_rows=None, sr=44100, channels=1, cn=None, label='sine')

      Generate Sine signal Asig object.

      :param freq: signal frequency (Default value = 440)
      :type freq: int, float
      :param amp: signal amplitude (Default value = 1.0)
      :type amp: int, float
      :param dur: duration in second. dur and num_rows only use one of the two. (Default value = 1.0)
      :type dur: float
      :param num_rows: number of rows (samples). dur and num_rows only use one of the two(Default value = None)
      :type num_rows: int
      :param sr: sampling rate (Default value = 44100)
      :type sr: int
      :param channels: number of channels (Default value = 1)
      :type channels: int
      :param cn: channel names as a list. The size needs to match the number of channels (Default value = None)
      :type cn: list of string
      :param label: identifier of the object (Default value = "sine")
      :type label: string

      :rtype: Asig


   .. py:method:: cos(freq=440, amp=1.0, dur=None, n_rows=None, sr=44100, channels=1, cn=None, label='cosine')

      Generate Cosine signal Asig object.

      :param freq: signal frequency (Default value = 440)
      :type freq: int, float
      :param amp: signal amplitude (Default value = 1.0)
      :type amp: int, float
      :param dur: duration in second. dur and num_rows only use one of the two. (Default value = 1.0)
      :type dur: int, float
      :param num_rows: number of rows (samples). dur and num_rows only use one of the two(Default value = None)
      :type num_rows: int
      :param sr: sampling rate (Default value = 44100)
      :type sr: int
      :param channels: number of channels (Default value = 1)
      :type channels: int
      :param cn: channel names as a list. The size needs to match the number of channels (Default value = None)
      :type cn: list of string
      :param label: identifier of the object (Default value = "cosine")
      :type label: string

      :rtype: Asig


   .. py:method:: square(freq=440, amp=1.0, dur=None, n_rows=None, duty=0.5, sr=44100, sample_shift=0.5, channels=1, cn=None, label='square')

      Generate square wave signal Asig object.

      :param freq: signal frequency (Default value = 440)
      :type freq: int, float
      :param amp: signal amplitude (Default value = 1.0)
      :type amp: int, float
      :param dur: duration in second. dur and num_rows only use one of the two. (Default value = 1.0)
      :type dur: int, float
      :param num_rows: number of row (samples). dur and num_rows only use one of the two(Default value = None)
      :type num_rows: int
      :param duty: duty cycle (Default value = 0.4)
      :type duty: float
      :param sr: sampling rate (Default value = 44100)
      :type sr: int
      :param channels: number of channels (Default value = 1)
      :type channels: int
      :param cn: channel names as a list. The size needs to match the number of channels (Default value = None)
      :type cn: list of string
      :param label: identifier of the object (Default value = "square")
      :type label: string

      :rtype: Asig


   .. py:method:: sawtooth(freq=440, amp=1.0, dur=None, n_rows=None, width=1.0, sr=44100, channels=1, cn=None, label='sawtooth')

      Generate sawtooth wave signal Asig object.

      :param freq: signal frequency (Default value = 440)
      :type freq: int, float
      :param amp: signal amplitude (Default value = 1.0)
      :type amp: int, float
      :param dur: duration in second. dur and num_rows only use one of the two. (Default value = 1.0)
      :type dur: int, float
      :param num_rows: number of rows (samples). dur and num_rows only use one of the two(Default value = None)
      :type num_rows: int
      :param width: tooth width (Default value = 1.0)
      :type width: float
      :param sr: sampling rate (Default value = 44100)
      :type sr: int
      :param channels: number of channels (Default value = 1)
      :type channels: int
      :param cn: channel names as a list. The size needs to match the number of channels (Default value = None)
      :type cn: list of string
      :param label: identifier of the object (Default value = "sawtooth")
      :type label: string

      :rtype: Asig


   .. py:method:: noise(type='white', amp=1.0, dur=None, n_rows=None, sr=44100, channels=1, cn=None, label='noise')

      Generate noise signal Asig object.

      :param type: type of noise, currently available: 'white' and 'pink' (Default value = 'white')
      :type type: string
      :param amp: signal amplitude (Default value = 1.0)
      :type amp: int, float
      :param dur: duration in second. dur and num_rows only use one of the two. (Default value = 1.0)
      :type dur: int, float
      :param num_rows: number of rows (samples). dur and num_rows only use one of the two(Default value = None)
      :type num_rows: int
      :param sr: sampling rate (Default value = 44100)
      :type sr: int
      :param channels: number of channels (Default value = 1)
      :type channels: int
      :param cn: channel names as a list. The size needs to match the number of channels (Default value = None)
      :type cn: list of string
      :param label: identifier of the object (Default value = "square")
      :type label: string

      :rtype: Asig



.. py:function:: basicplot(data, ticks, channels, offset=0, scale=1, cn=None, ax=None, typ='plot', cmap='inferno', xlim=None, ylim=None, xlabel='', ylabel='', show_bar=False, **kwargs)

   Basic version of the plot for pya, this can be directly used
   by Asig. Aspec/Astft/Amfcc will have different extra setting
   and type.

   :param data: data array
   :type data: numpy.ndarray
   :param channels: number of channels
   :type channels: int
   :param axis: Plot image on the matplotlib axis if it was given.
                Default is None, which use plt.gca()
   :type axis: matplotlib.axes, optional
   :param typ: Plot type.
   :type typ: str, optional


.. py:function:: gridplot(pya_objects, colwrap=1, cbar_ratio=0.04, figsize=None)

   Create a grid plot of pya objects which have plot() methods,
   i.e. Asig, Aspec, Astft, Amfcc.
   It takes a list of pya_objects and plot each object into a grid.
   You can mix different types of plots
   together.

   .. rubric:: Examples

   # plot all 4 different pya objects in 1 column,
   amfcc and astft use pcolormesh so colorbar will
   # be displayed as well
   gridplot([asig, amfcc, aspec, astft], colwrap=2,
             cbar_ratio=0.08, figsize=[10, 10]);

   :param pya_objects: A list of pya objects with the plot() method.
   :type pya_objects: iterable object
   :param colwrap: Wrap column at position.
                   Can be considered as the column size. Default is 1, meaning 1 column.
   :type colwrap: int, optional
   :param cbar_ratio: For each column create another column reserved for the colorbar.
                      This is the ratio of the width relative to the plot.
                      0.04 means 4% of the width of the data plot.
   :type cbar_ratio: float, optional
   :param figsize: width, height of the entire image in inches. Default size is (6.4, 4.8)
   :type figsize: tuple, optional

   :returns: **fig** -- The plt.figure() object
   :rtype: plt.figure()


.. py:function:: audio_read(fp)


.. py:exception:: _error


   Bases: :py:obj:`Exception`

   Common base class for all non-exit exceptions.


.. py:function:: linlin(x, smi, sma, dmi, dma)

   Linear mapping

   :param x: input value
   :type x: float
   :param smi: input range's minimum
   :type smi: float
   :param sma: input range's maximum
   :type sma: float
   :param dmi: input range's minimum
   :type dmi: float
   :param dma:

   :returns: **_** -- mapped output
   :rtype: float


.. py:function:: midicps(m)

   Convert midi number into cycle per second


.. py:function:: cpsmidi(c)

   Convert cycle per second into midi number


.. py:function:: dbamp(db)

   Convert db to amplitude


.. py:function:: ampdb(amp)

   Convert amplitude to db


.. py:function:: spectrum(sig, samples, channels, sr)

   Return spectrum of a given signal. This method return spectrum matrix if input signal is multi-channels.

   :param sig: signal array
   :type sig: numpy.ndarray
   :param samples: total amount of samples
   :type samples: int
   :param channels: signal channels
   :type channels: int
   :param sr: sampling rate
   :type sr: int

   :returns: * **frq** (*numpy.ndarray*) -- frequencies
             * **Y** (*numpy.ndarray*) -- FFT of the signal.


.. py:function:: normalize(d)

   Return the normalized input array


.. py:function:: audio_from_file(path, dtype=np.float32)

   Load an audio buffer using audioread.
   This loads one block at a time, and then concatenates the results.


.. py:function:: buf_to_float(x, n_bytes=2, dtype=np.float32)

   Convert an integer buffer to floating point values.
   This is primarily useful when loading integer-valued wav data
   into numpy arrays.
   .. seealso:: :obj:`buf_to_float`

   :param x: The integer-valued data buffer
   :type x: np.ndarray [dtype=int]
   :param n_bytes: The number of bytes per sample in `x`
   :type n_bytes: int [1, 2, 4]
   :param dtype: The target output type (default: 32-bit float)
   :type dtype: numeric type

   :returns: **x_float** -- The input data buffer cast to floating point
   :rtype: np.ndarray [dtype=float]


.. py:function:: device_info()

   Return a formatted string about available audio devices and their info


.. py:function:: find_device(min_input=0, min_output=0)


.. py:function:: padding(x, width, tail=True, constant_values=0)

   Pad signal with certain width, support 1-3D tensors.
   Use it to add silence to a signal
   TODO: CHECK pad array


   :param x: A numpy array
   :type x: np.ndarray
   :param width: The amount of padding.
   :type width: int
   :param tail: If true pad to the tail, else pad to the start.
   :type tail: bool
   :param constant_values: The value to be padded, add None will pad nan to the array
   :type constant_values: int or float or None

   :returns: **_** -- Padded array
   :rtype: np.ndarray


.. py:function:: is_pow2(val)

   Check if input is a power of 2 return a bool result.


.. py:function:: next_pow2(x)

   Find the closest pow of 2 that is great or equal or x,
   based on shift_bit_length

   :param x: A positive number
   :type x: int

   :returns: **_** -- The cloest  integer that is greater or equal to input x.
   :rtype: int


.. py:function:: round_half_up(number)

   Round up if >= .5


.. py:function:: rolling_window(a, window, step=1)


.. py:function:: signal_to_frame(sig, n_per_frame, frame_step, window=None, stride_trick=True)

   Frame a signal into overlapping frames.

   :param sig: The audio signal
   :type sig: numpy.ndarray
   :param n_per_frame: Number of samples each frame
   :type n_per_frame: int
   :param frame_step: Number of samples after the start of the previous frame that the next frame should begin.
   :type frame_step: int
   :param window: A window array, e.g,
   :type window: numpy.ndarray or None
   :param stride_trick: Use stride trick to compute the rolling window and window multiplication faster
   :type stride_trick: bool

   :returns: **_** -- an array of frames.
   :rtype: numpy.ndarray


.. py:function:: magspec(frames, NFFT)

   Compute the magnitude spectrum of each frame in frames.
   If frames is an NxD matrix, output will be Nx(NFFT/2+1).

   :param frames: The framed array, each row is a frame, can be just a single frame.
   :type frames: numpy.ndarray
   :param NFFT: FFT length. If NFFT > frame_len, the frames are zero_padded.
   :type NFFT: int

   :returns: **_** -- If frames is an NxD matrix, output will be Nx(NFFT/2+1).
             Each row will be the magnitude spectrum of the corresponding frame.
   :rtype: numpy.ndarray


.. py:function:: powspec(frames, NFFT)

   Compute the power spectrum of each frame in frames,
   first comeputer the magnitude spectrum

   :param frames: Framed signal, can be just a single frame.
   :type frames: numpy.ndarray
   :param NFFT: The FFT length to use. If NFFT > frame_len, the frames are zero-padded.
   :type NFFT: int

   :returns: **_** -- Power spectrum of the framed signal.
             Each row has the size of NFFT / 2 + 1 due to rfft.
   :rtype: numpy array


.. py:function:: hz2mel(hz)

   Convert a value in Hertz to Mels

   :param hz: value in Hz, can be an array
   :type hz: number of array
   :param Returns:
   :param --------:
   :param _: value in Mels, same type as the input.
   :type _: number of array


.. py:function:: mel2hz(mel)

   Convert a value in Hertz to Mels

   :param hz: value in Hz, can be an array
   :type hz: number of array
   :param Returns:
   :param --------:
   :param _: value in Mels, same type as the input.
   :type _: number of array


.. py:class:: DummyBackend(dummy_devices=None)


   Bases: :py:obj:`pya.backend.base.BackendBase`

   Helper class that provides a standard way to create an ABC using
   inheritance.

   .. py:attribute:: dtype
      :value: 'float32'

      

   .. py:attribute:: range
      :value: 1

      

   .. py:attribute:: bs
      :value: 256

      

   .. py:method:: get_device_count()


   .. py:method:: get_device_info_by_index(idx)


   .. py:method:: get_default_input_device_info()


   .. py:method:: get_default_output_device_info()


   .. py:method:: open(*args, input_flag, output_flag, rate, frames_per_buffer, channels, stream_callback=None, **kwargs)


   .. py:method:: process_buffer(buffer)


   .. py:method:: terminate()



.. py:class:: PyAudioBackend(format=pyaudio.paFloat32)


   Bases: :py:obj:`pya.backend.base.BackendBase`

   Helper class that provides a standard way to create an ABC using
   inheritance.

   .. py:attribute:: _boot_delay
      :value: 0.5

      

   .. py:attribute:: bs
      :value: 512

      

   .. py:method:: get_device_count()


   .. py:method:: get_device_info_by_index(idx)


   .. py:method:: get_default_input_device_info()


   .. py:method:: get_default_output_device_info()


   .. py:method:: open(rate, channels, input_flag, output_flag, frames_per_buffer, input_device_index=None, output_device_index=None, start=True, input_host_api_specific_stream_info=None, output_host_api_specific_stream_info=None, stream_callback=None)


   .. py:method:: process_buffer(buffer)


   .. py:method:: terminate()



.. py:data:: _LOGGER

   

.. py:function:: determine_backend(force_webaudio=False, port=8765)


.. py:function:: startup(**kwargs)


.. py:function:: shutdown(**kwargs)


